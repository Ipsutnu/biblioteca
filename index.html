<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Biblioteca Oculta</title>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@600&family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="particles" id="particles"></div>
  <div class="mini-particles" id="miniParticles"></div>
  <div class="extra-particles" id="extraParticles"></div>

  <div class="asmr-gradients"></div>
  <div class="light-waves"></div>
  
  <div class="custom-cursor" id="cursor"></div>

  <header>
    <div class="logo-container" style="position: relative; display: inline-block;">
      <img src="logo.png" alt="Logo" class="logo" />
      <div class="logo-particles" id="logoParticles"></div>
    </div>
  </header>

  <section class="galeria">
    <a href="livros/livro1.pdf" target="_blank" data-asmr-src="audios/page-turn-1.mp3"><img src="capas/livro1.png" alt="Livro 1"></a>
    <a href="livros/livro2.pdf" target="_blank" data-asmr-src="audios/page-turn-2.mp3"><img src="capas/livro2.png" alt="Livro 2"></a>
    <a href="livros/livro3.pdf" target="_blank" data-asmr-src="audios/page-turn-3.mp3"><img src="capas/livro3.png" alt="Livro 3"></a>
    <a href="livros/livro4.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro4.png" alt="Livro 4"></a>
    <a href="livros/livro5.pdf" target="_blank" data-asmr-src="audios/page-turn-1.mp3"><img src="capas/livro5.jpg" alt="Livro 5"></a>
    <a href="livros/livro6.pdf" target="_blank" data-asmr-src="audios/page-turn-2.mp3"><img src="capas/livro6.png" alt="Livro 6"></a>
    <a href="livros/livro7.pdf" target="_blank" data-asmr-src="audios/page-turn-3.mp3"><img src="capas/livro7.jpg" alt="Livro 7"></a>
    <a href="livros/livro8.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro8.png" alt="Livro 8"></a>
    <a href="livros/livro9.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro9.png" alt="Livro 9"></a>
    <a href="livros/livro10.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro10.png" alt="Livro 10"></a>
    <a href="livros/livro11.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro11.png" alt="Livro 11"></a>
    <a href="livros/livro12.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro12.png" alt="Livro 12"></a>
    <a href="livros/livro13.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro13.png" alt="Livro 13"></a>
    <a href="livros/livro14.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro14.png" alt="Livro 14"></a>
    <a href="livros/livro15.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro15.png" alt="Livro 15"></a>
    <a href="livros/livro16.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro16.png" alt="Livro 16"></a>
    <a href="livros/livro17.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro17.png" alt="Livro 17"></a>
    <a href="livros/livro18.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro18.png" alt="Livro 18"></a>
    <a href="livros/livro19.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro19.png" alt="Livro 19"></a>
    <a href="livros/livro20.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro20.png" alt="Livro 20"></a>
  </section>

  <footer>
    Biblioteca Oculta
  </footer>

  <script>
    // --- Funções para criar partículas de fundo ---
    function createParticles(container, className, count, minDuration, maxDuration, minDelay, maxDelay) {
      if (!container) return;
      container.innerHTML = ''; // Limpa o contêiner

      for (let i = 0; i < count; i++) {
        const particle = document.createElement('div');
        particle.className = className;
        
        particle.x = Math.random() * window.innerWidth;
        particle.y = window.innerHeight + Math.random() * 100;

        particle.vx = 0;
        particle.vy = 0;

        particle.floatSpeedY = (0.5 + Math.random() * 1.5) * -1;
        particle.floatSpeedX = (Math.random() - 0.5) * 0.5;
        particle.rotation = Math.random() * 360;
        particle.rotationSpeed = (Math.random() - 0.5) * 0.2;

        particle.angle = Math.random() * Math.PI * 2;
        particle.orbitRadius = 0;
        particle.isOrbiting = false;
        particle.isAttracted = false;

        particle.style.left = particle.x + 'px';
        particle.style.top = particle.y + 'px';
        
        const delay = (minDelay + Math.random() * (maxDelay - minDelay)) * 1000;
        setTimeout(() => {
          container.appendChild(particle);
          allParticles.push(particle);
        }, delay);
      }
    }

    // --- Variáveis e Função para o efeito de atração e órbita das partículas (buraco negro) ---
    let mouseX = 0;
    let mouseY = 0;
    const attractionRadius = 150;
    const orbitRadiusRange = { min: 30, max: 90 };
    const attractionStrength = 0.001;
    const orbitSpeed = 0.03;
    const dampening = 0.95;

    let allParticles = [];  

    function animateParticles() {
        allParticles.forEach(particle => {
            const dx = mouseX - particle.x;
            const dy = mouseY - particle.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < attractionRadius) {
                if (!particle.isAttracted) {
                    particle.isAttracted = true;
                }

                if (distance < orbitRadiusRange.max) {
                    if (!particle.isOrbiting) {
                        particle.isOrbiting = true;
                        particle.orbitRadius = orbitRadiusRange.min + Math.random() * (orbitRadiusRange.max - orbitRadiusRange.min);
                        particle.angle = Math.atan2(dy, dx);
                    }

                    particle.angle += orbitSpeed; 
                    const targetX = mouseX + Math.cos(particle.angle) * particle.orbitRadius;
                    const targetY = mouseY + Math.sin(particle.angle) * particle.orbitRadius;

                    const forceToOrbitX = (targetX - particle.x) * attractionStrength * 5; 
                    const forceToOrbitY = (targetY - particle.y) * attractionStrength * 5;

                    particle.vx += forceToOrbitX;
                    particle.vy += forceToOrbitY;

                } else {
                    if (particle.isOrbiting) { 
                        particle.isOrbiting = false;
                        particle.orbitRadius = 0;
                    }
                    
                    const forceFactor = (attractionRadius - distance) / attractionRadius; 
                    particle.vx += dx * attractionStrength * forceFactor;
                    particle.vy += dy * attractionStrength * forceFactor;
                }

                particle.vx *= dampening;
                particle.vy *= dampening;

            } else {
                if (particle.isAttracted) { 
                    particle.isAttracted = false;
                    particle.isOrbiting = false;
                    particle.orbitRadius = 0;
                }

                particle.vx *= dampening; 
                particle.vy *= dampening; 

                const floatAdjustSpeed = 0.05; 
                particle.vx += (particle.floatSpeedX - particle.vx) * floatAdjustSpeed;
                particle.vy += (particle.floatSpeedY - particle.vy) * floatAdjustSpeed;

                particle.rotation += particle.rotationSpeed;

                if (particle.y < -50) { 
                    particle.y = window.innerHeight + 50;
                    particle.x = Math.random() * window.innerWidth;
                    particle.vx = 0; 
                    particle.vy = 0; 
                    particle.floatSpeedY = (0.5 + Math.random() * 1.5) * -1;
                    particle.floatSpeedX = (Math.random() - 0.5) * 0.5;
                    particle.rotation = Math.random() * 360;
                    particle.rotationSpeed = (Math.random() - 0.5) * 0.2;
                }
            }

            particle.x += particle.vx;
            particle.y += particle.vy;

            particle.style.left = particle.x + 'px';
            particle.style.top = particle.y + 'px';
            particle.style.transform = `rotate(${particle.rotation}deg)`; 

        });
        requestAnimationFrame(animateParticles); 
    }

    // --- Lógica para a animação do brilho da logo ---
    function createLogoSparkPath(particlesContainer, onSparkFinishCallback) {
        if (!particlesContainer) return;

        particlesContainer.innerHTML = ''; 
        const numVertices = 6; 
        const radius = 42; 
        const rotationInputDegrees = 30; 
        const rotationOffsetRadians = (rotationInputDegrees * Math.PI) / 180;

        const logoCenterOffset = { x: -1, y: -6 };

        const spark = document.createElement('div');
        spark.className = 'logo-spark';
        particlesContainer.appendChild(spark);

        let keyframes = [];
        let totalDuration = 0;
        const segmentDuration = 0.3; 
        const pauseBetweenSegments = 0.05; 

        // Start from opacity 0 at the center-ish position
        keyframes.push({
            transform: `translate(${logoCenterOffset.x}px, ${logoCenterOffset.y}px) rotate(${rotationOffsetRadians * (180 / Math.PI) + 88}deg)`,
            opacity: 0
        });

        let lastTargetX, lastTargetY, lastFinalRotation; // To store the last position for fade-out

        for (let i = 0; i <= numVertices; i++) {
            let angle = (Math.PI * 2 / numVertices) * i + rotationOffsetRadians;
            lastTargetX = Math.cos(angle) * radius;
            lastTargetY = Math.sin(angle) * radius;
            lastFinalRotation = angle * (180 / Math.PI) + 88;

            keyframes.push({
                transform: `translate(${lastTargetX + logoCenterOffset.x}px, ${lastTargetY + logoCenterOffset.y}px) rotate(${lastFinalRotation}deg)`,
                opacity: 1 // Full opacity during the path
            });
            totalDuration += segmentDuration;

            if (i < numVertices) {
                keyframes.push({
                    transform: `translate(${lastTargetX + logoCenterOffset.x}px, ${lastTargetY + logoCenterOffset.y}px) rotate(${lastFinalRotation}deg)`,
                    opacity: 1
                });
                totalDuration += pauseBetweenSegments;
            }
        }

        // Add the final keyframe to fade out the spark at its last position
        keyframes.push({
            transform: `translate(${lastTargetX + logoCenterOffset.x}px, ${lastTargetY + logoCenterOffset.y}px) rotate(${lastFinalRotation}deg)`,
            opacity: 0 // Fade out from the end of the path
        });

        const timingOptions = {
            duration: totalDuration * 1000, 
            easing: 'ease-in-out',
            fill: 'forwards' 
        };

        const animation = spark.animate(keyframes, timingOptions);

        animation.onfinish = () => {
            spark.remove();
            if (onSparkFinishCallback) {
                onSparkFinishCallback();
            }
        };

        return animation; 
    }

    // --- Variáveis de Estado Globais para as Transformações Combinadas da Logo e Galeria ---
    let currentScrollScale = 1; // Escala atual da logo (1 = tamanho original)
    let currentLogoRotation = 0; // Rotação total acumulada para a logo (em graus)
    let isHovering = false; // Flag global para o estado de hover sobre a logo
    
    // Variáveis para o movimento vertical da galeria e seu fator de movimento
    let galleryTranslateY = 0;
    const galleryMovementFactor = 180; // Quão mais a galeria se move para baixo (original: 150)

    // Dimensões iniciais da logo para cálculo de escala/translação (deve corresponder ao CSS)
    const initialLogoBaseSize = 170; // max-width/height: 120px no CSS (ajuste isso no CSS e aqui)
    const maxLogoScale = 4; // Escala máxima que a logo pode atingir
    const scaleSpeedFactor = 0.005; // Velocidade com que a logo escala ao scrollar (mais lento)

    // Variáveis para o movimento vertical da logo
    let logoTranslateY = 0; // A quantidade de pixels que a logo deve se mover para baixo
    const logoMoveThresholdRatio = 1;  
    let maxLogoTranslateYValue = 0; 

    // Variáveis para a rotação da logo ao scroll
    let scrollRotationSpeed = 0; // Velocidade de rotação atual (graus por frame)
    const scrollRotationFactor = 0.06; // Quão rápido a logo gira com o scroll (quando a rotação é ativa)
    const scrollRotationDampening = 0.97; // Fator de desaceleração da rotação (era 0.99)
    let scrollTimeout;  
    let animationFrameId; 

    // Variável para evitar conflito com a rotação de 180° no hover
    let isHoverRotationActive = false;

    // Função que aplica a translação vertical ao logo-container e a escala/rotação à logo
    function applyLogoTransform() {
        const logoContainer = document.querySelector('.logo-container');
        const logo = document.querySelector('.logo');
        if (!logoContainer || !logo) return;

        let currentLogoTranslateY = 0;
        if (currentScrollScale > 1) {
            const scaleProgress = (currentScrollScale - 1) / (maxLogoScale - 1);
            currentLogoTranslateY = scaleProgress * maxLogoTranslateYValue * logoMoveThresholdRatio;
            currentLogoTranslateY = Math.min(currentLogoTranslateY, maxLogoTranslateYValue);
        }
        logoTranslateY = currentLogoTranslateY;

        logoContainer.style.transform = `translateY(${logoTranslateY}px)`;
        // Ensure rotation applies from the current angle
        logo.style.transform = `scale(${currentScrollScale}) rotate(${currentLogoRotation}deg)`;
    }

    // Função para animar a rotação contínua da logo quando o scroll para
    function animateLogoRotation() {
        if (Math.abs(scrollRotationSpeed) > 0.005) { // Continua animando se a velocidade for detectável (limiar menor)
            currentLogoRotation += scrollRotationSpeed;
            scrollRotationSpeed *= scrollRotationDampening; // Reduz a velocidade de rotação gradualmente
            applyLogoTransform(); 
            animationFrameId = requestAnimationFrame(animateLogoRotation);
        } else {
            scrollRotationSpeed = 0; 
            cancelAnimationFrame(animationFrameId);
            // Only snap to 0 if rotation is negligible and not being controlled by hover
            if (Math.abs(currentLogoRotation % 360) < 0.1 && !isHoverRotationActive) {
                currentLogoRotation = 0;
                applyLogoTransform(); // Ensure it snaps to 0 if it was almost there
            }
        }
    }

    // Função para ajustar a posição vertical da galeria
    function applyGalleryTransform() {
        const gallery = document.querySelector('.galeria');
        if (!gallery) return;
        galleryTranslateY = (currentScrollScale - 1) * galleryMovementFactor;
        gallery.style.transform = `translateY(${galleryTranslateY}px)`;
    }

    function setupLogoEffect() {
        const logo = document.querySelector('.logo');
        const logoContainer = document.querySelector('.logo-container');
        const logoParticlesContainer = document.getElementById('logoParticles');
        const logoHoverRotationDegrees = 180;  
        const logoRotationDuration = 1.9; 
        let isSparkAnimating = false;
        let sparkTimer;

        if (!logo || !logoContainer || !logoParticlesContainer) return;

        maxLogoTranslateYValue = (window.innerHeight / 2) - (initialLogoBaseSize / 2);

        logo.addEventListener('mouseenter', () => {
            isHovering = true;
            if (currentScrollScale < 1.05) { 
                isHoverRotationActive = true;
                // Set transition BEFORE updating currentLogoRotation to ensure smooth animation
                logo.style.transition = `transform ${logoRotationDuration}s ease-out`;
                currentLogoRotation += logoHoverRotationDegrees; 
                applyLogoTransform();
                // After the main hover rotation transition, set a faster transition for subsequent changes
                setTimeout(() => {
                    if (isHovering && currentScrollScale < 1.05) { 
                        logo.style.transition = `transform 0.4s ease-out`;
                    }
                }, logoRotationDuration * 1000); 
            }

            if (currentScrollScale < 1.05 && !isSparkAnimating) {
                if (sparkTimer) clearTimeout(sparkTimer); 
                sparkTimer = setTimeout(() => {
                    if (isHovering && currentScrollScale < 1.05) { 
                        isSparkAnimating = true;
                        createLogoSparkPath(logoParticlesContainer, () => {
                            isSparkAnimating = false;
                        });
                    }
                }, (logoRotationDuration * 1000) + 700); 
            } else if (currentScrollScale >= 1.05) {
                if (sparkTimer) clearTimeout(sparkTimer);
                if (isSparkAnimating) {
                    logoParticlesContainer.innerHTML = '';
                    isSparkAnimating = false;
                }
            }
        });

        logo.addEventListener('mouseleave', () => {
            isHovering = false;
            
            // Set transition BEFORE updating the rotation to ensure smooth return
            logo.style.transition = `transform ${logoRotationDuration}s ease-out`; 

            // If hover rotation was active, reverse it.
            // Then, reset to a clean multiple of 360 degrees or exactly 0.
            if (isHoverRotationActive) {
                isHoverRotationActive = false;
                currentLogoRotation -= logoHoverRotationDegrees; // Reverse the last 180 deg rotation
            }
            
            // Normalize currentLogoRotation to be a multiple of 360 to smoothly return to an "original facing" position
            // This ensures it spins back to the nearest 0, 360, 720, etc.
            currentLogoRotation = Math.round(currentLogoRotation / 360) * 0;

            // Reset scale and translation values to their initial states
            currentScrollScale = 1;
            logoTranslateY = 0;
            galleryTranslateY = 0;

            // Apply all transformations for a smooth return
            logoContainer.style.transition = `transform 1.8s ease-out`; 
            const gallery = document.querySelector('.galeria');
            if (gallery) {
                gallery.style.transition = `transform 1.4s ease-out`; 
            }

            applyLogoTransform(); 
            applyGalleryTransform();

            // Clear spark related timers/animations
            if (sparkTimer) {
                clearTimeout(sparkTimer); 
            }
            if (isSparkAnimating) { 
                logoParticlesContainer.innerHTML = '';
                isSparkAnimating = false;
            }
        });

        // --- Handle mouse wheel scroll over the logo ---
        logo.addEventListener('wheel', (event) => {
            event.preventDefault(); 

            // Set short transitions for responsiveness during scroll
            logo.style.transition = `transform 2s ease-out`; 
            logoContainer.style.transition = `transform 2s ease-out`;
            
            const gallery = document.querySelector('.galeria');
            if (gallery) {
                gallery.style.transition = `transform 2s ease-out`; 
            }

            const scrollAmount = -event.deltaY; // Negative for scroll up, Positive for scroll down

            // 1. Logic to INCREASE/DECREASE logo scale and move gallery
            currentScrollScale += scaleSpeedFactor * -scrollAmount; 
            currentScrollScale = Math.max(1, Math.min(maxLogoScale, currentScrollScale)); 

            // 2. Logic for ROTATION on scroll
            const currentLogoYProgress = (logoTranslateY / maxLogoTranslateYValue);

            let dynamicRotationFactor = 0;
            if (currentLogoYProgress >= 0.25) { 
                const rotationProgress = Math.min(1, (currentLogoYProgress - 0.25) / 0.75); 
                dynamicRotationFactor = scrollRotationFactor * rotationProgress;
            }

            if (dynamicRotationFactor > 0 || Math.abs(scrollRotationSpeed) > 0.005) {
                currentLogoRotation += (scrollAmount * dynamicRotationFactor);  // Add to current rotation
                scrollRotationSpeed = (scrollAmount * dynamicRotationFactor); 
            } else {
                if (Math.abs(scrollRotationSpeed) > 0.005) { 
                    scrollRotationSpeed *= scrollRotationDampening; 
                } else {
                    scrollRotationSpeed = 0; 
                }

                // If not actively scrolling or hovering, gently bring rotation towards the nearest multiple of 360
                // This helps avoid tiny residual rotations but doesn't instantly snap.
                if (Math.abs(currentLogoRotation % 360) > 0.1 && !isHoverRotationActive) { 
                     currentLogoRotation *= 0.99; 
                } else if (!isHoverRotationActive) {
                    currentLogoRotation = Math.round(currentLogoRotation / 360) * 360; // Snap to nearest 360 multiple
                }
            }

            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                if (Math.abs(scrollRotationSpeed) > 0.005) { 
                    cancelAnimationFrame(animationFrameId); 
                    animateLogoRotation();
                } else {
                    scrollRotationSpeed = 0; 
                    cancelAnimationFrame(animationFrameId); 
                }
            }, 100); 

            applyLogoTransform();
            applyGalleryTransform();

            if (currentScrollScale > 1.1) { 
                if (sparkTimer) clearTimeout(sparkTimer);
                if (isSparkAnimating) {
                    logoParticlesContainer.innerHTML = '';
                    isSparkAnimating = false;
                }
            } else if (currentScrollScale < 1.1 && isHovering && !isSparkAnimating) { 
                if (sparkTimer) clearTimeout(sparkTimer);
                sparkTimer = setTimeout(() => {
                    if (isHovering && currentScrollScale < 1.1) {
                        isSparkAnimating = true;
                        createLogoSparkPath(logoParticlesContainer, () => {
                            isSparkAnimating = false;
                        });
                    }
                }, (logoRotationDuration * 1000) + 700);
            }
        });
    }

    // --- Efeito de seleção de livro na galeria (AGORA COM ASMR E EMPURRÃO VERTICAL E HORIZONTAL) ---
    let lastPlayedAudio = null;
    const asmrAudios = [
        new Audio('audios/page-turn-1.mp3'),
        new Audio('audios/page-turn-2.mp3'),
        new Audio('audios/page-turn-3.mp3'),
        new Audio('audios/page-turn-4.mp3')
    ];
    asmrAudios.forEach(audio => audio.load());

    function setupBookSelectionEffect() {
        const galleryItems = document.querySelectorAll('.galeria a');

        galleryItems.forEach(item => {
            item.addEventListener('mouseenter', function() {
                this.classList.add('selected-book');
                
                const prevSibling = this.previousElementSibling;
                if (prevSibling && prevSibling.matches && prevSibling.matches('.galeria a')) {
                    prevSibling.classList.add('pushed-aside-right');
                }
                const nextSibling = this.nextElementSibling;
                if (nextSibling && nextSibling.matches && nextSibling.matches('.galeria a')) {
                    nextSibling.classList.add('pushed-aside-left');
                }

                const itemRect = this.getBoundingClientRect();
                
                galleryItems.forEach(otherItem => {
                    if (otherItem === this) return;

                    const otherItemRect = otherItem.getBoundingClientRect();

                    if (otherItemRect.bottom < itemRect.top && 
                        otherItemRect.left < itemRect.right && 
                        otherItemRect.right > itemRect.left) {
                        otherItem.classList.add('pushed-down');
                    } 
                    else if (otherItemRect.top > itemRect.bottom && 
                             otherItemRect.left < itemRect.right && 
                             otherItemRect.right > itemRect.left) {
                        otherItem.classList.add('pushed-up');
                    }
                });

                if (lastPlayedAudio) {
                    lastPlayedAudio.pause();
                    lastPlayedAudio.currentTime = 0;
                }
                const randomIndex = Math.floor(Math.random() * asmrAudios.length);
                const audio = asmrAudios[randomIndex].cloneNode();
                audio.volume = 0.4;
                audio.play().catch(e => console.error("Erro ao tocar áudio ASMR:", e));
                lastPlayedAudio = audio;
            });

            item.addEventListener('mouseleave', function() {
                this.classList.remove('selected-book');
                
                const prevSibling = this.previousElementSibling;
                if (prevSibling && prevSibling.matches && prevSibling.matches('.galeria a')) {
                    prevSibling.classList.remove('pushed-aside-right');
                }
                const nextSibling = this.nextElementSibling;
                if (nextSibling && nextSibling.matches && nextSibling.matches('.galeria a')) {
                    nextSibling.classList.remove('pushed-aside-left');
                }

                galleryItems.forEach(otherItem => {
                    otherItem.classList.remove('pushed-down', 'pushed-up');
                });

                if (lastPlayedAudio) {
                    lastPlayedAudio.pause();
                    lastPlayedAudio.currentTime = 0;
                }
            });

            item.addEventListener('click', () => {
                if (lastPlayedAudio) {
                    lastPlayedAudio.pause();
                    lastPlayedAudio.currentTime = 0;
                }
            });
        });
    }

    // --- Cursor personalizado ---
    function setupCustomCursor() {
      const cursor = document.getElementById('cursor');
      if (!cursor) return;
      let cursorX = 0, cursorY = 0;  
      const cursorSizeOffset = cursor.offsetWidth / 2; 

      document.addEventListener('mousemove', (e) => {  
        mouseX = e.clientX;  
        mouseY = e.clientY;  
      });

      function animateCursor() {
        cursorX += (mouseX - cursorX) * 0.12;  
        cursorY += (mouseY - cursorY) * 0.12;  
        cursor.style.left = cursorX - cursorSizeOffset + 'px';
        cursor.style.top = cursorY - cursorSizeOffset + 'px';
        requestAnimationFrame(animateCursor);  
      }
      animateCursor();  

      const interactiveElements = document.querySelectorAll('a, img.logo');
      interactiveElements.forEach(el => {
        el.addEventListener('mouseenter', () => { cursor.style.transform = 'scale(1.3)'; });
        el.addEventListener('mouseleave', () => { cursor.style.transform = 'scale(1)'; });
      });
    }

    // --- Função para embaralhar um array (Fisher-Yates) ---
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    // --- Inicialização de todos os efeitos quando o DOM estiver carregado ---
    document.addEventListener('DOMContentLoaded', () => {
      const gallery = document.querySelector('.galeria');
      const galleryItems = Array.from(gallery.children);
      
      shuffleArray(galleryItems);

      galleryItems.forEach(item => gallery.appendChild(item));

      const particlesContainer = document.getElementById('particles');
      const miniParticlesContainer = document.getElementById('miniParticles');
      const extraParticlesContainer = document.getElementById('extraParticles');

      createParticles(particlesContainer, 'particle', 19, 15, 10, 0, 15);
      createParticles(miniParticlesContainer, 'mini-particle', 60, 20, 15, 0, 20);
      createParticles(extraParticlesContainer, 'extra-particle', 45, 25, 20, 0, 25);

      animateParticles(); 

      setupCustomCursor();
      setupLogoEffect();
      setupBookSelectionEffect();
    });
  </script>
</body>
</html>
