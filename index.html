<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Biblioteca Oculta</title>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@600&family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="particles" id="particles"></div>
  <div class="mini-particles" id="miniParticles"></div>
  <div class="extra-particles" id="extraParticles"></div>

  <div class="asmr-gradients"></div>
  <div class="light-waves"></div>
  
  <div class="custom-cursor" id="cursor"></div>

  <header>
    <div class="logo-container" style="position: relative; display: inline-block;">
      <img src="logo.png" alt="Logo" class="logo" />
      <div class="logo-particles" id="logoParticles"></div>
    </div>
  </header>

  <section class="galeria">
    <a href="livros/livro1.pdf" target="_blank" data-asmr-src="audios/page-turn-1.mp3"><img src="capas/livro1.png" alt="Livro 1"></a>
    <a href="livros/livro2.pdf" target="_blank" data-asmr-src="audios/page-turn-2.mp3"><img src="capas/livro2.png" alt="Livro 2"></a>
    <a href="livros/livro3.pdf" target="_blank" data-asmr-src="audios/page-turn-3.mp3"><img src="capas/livro3.png" alt="Livro 3"></a>
    <a href="livros/livro4.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro4.png" alt="Livro 4"></a>
    <a href="livros/livro5.pdf" target="_blank" data-asmr-src="audios/page-turn-1.mp3"><img src="capas/livro5.jpg" alt="Livro 5"></a>
    <a href="livros/livro6.pdf" target="_blank" data-asmr-src="audios/page-turn-2.mp3"><img src="capas/livro6.png" alt="Livro 6"></a>
    <a href="livros/livro7.pdf" target="_blank" data-asmr-src="audios/page-turn-3.mp3"><img src="capas/livro7.jpg" alt="Livro 7"></a>
    <a href="livros/livro8.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro8.png" alt="Livro 8"></a>
    <a href="livros/livro9.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro9.png" alt="Livro 9"></a>
<a href="livros/livro10.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro10.png" alt="Livro 10"></a>
<a href="livros/livro11.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro11.png" alt="Livro 11"></a>
<a href="livros/livro12.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro12.png" alt="Livro 12"></a>
	
    </section>

  <footer>
    Biblioteca Oculta
  </footer>

  <script>
    // --- Funções para criar partículas de fundo (agora 100% controladas por JS) ---
    function createParticles(container, className, count, minDuration, maxDuration, minDelay, maxDelay) {
      if (!container) return;
      container.innerHTML = ''; // Limpa o contêiner

      for (let i = 0; i < count; i++) {
        const particle = document.createElement('div');
        particle.className = className;
        
        // Initial random position (JS will move them up)
        particle.x = Math.random() * window.innerWidth;
        particle.y = window.innerHeight + Math.random() * 100; // Start slightly below screen

        particle.vx = 0; // Current velocity X
        particle.vy = 0; // Current velocity Y

        // Properties for floating when not attracted
        particle.floatSpeedY = (0.5 + Math.random() * 1.5) * -1; // Negative to move up
        particle.floatSpeedX = (Math.random() - 0.5) * 0.5; // Slight horizontal drift
        particle.rotation = Math.random() * 360; // Initial rotation
        particle.rotationSpeed = (Math.random() - 0.5) * 0.2; // Speed of rotation

        particle.angle = Math.random() * Math.PI * 2; // For orbiting
        particle.orbitRadius = 0;
        particle.isOrbiting = false;
        particle.isAttracted = false;

        // Set initial position directly
        particle.style.left = particle.x + 'px';
        particle.style.top = particle.y + 'px';
        
        const delay = (minDelay + Math.random() * (maxDelay - minDelay)) * 1000;
        setTimeout(() => {
          container.appendChild(particle);
          allParticles.push(particle);
        }, delay);
      }
    }

    // --- Variáveis e Função para o efeito de atração e órbita das partículas (buraco negro) ---
    let mouseX = 0;
    let mouseY = 0;
    const attractionRadius = 150; // Raio de influência do mouse em pixels para atração inicial
    const orbitRadiusRange = { min: 30, max: 90 }; // Faixa de raio para a órbita final
    const attractionStrength = 0.001; // Força da atração (valor menor para suavidade)
    const orbitSpeed = 0.03; // Velocidade angular da órbita
    const dampening = 0.95; // Reduz a velocidade para evitar movimento infinito

    let allParticles = []; 

    function animateParticles() {
        allParticles.forEach(particle => {
            const dx = mouseX - particle.x;
            const dy = mouseY - particle.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < attractionRadius) {
                // Particle is within attraction radius
                if (!particle.isAttracted) {
                    particle.isAttracted = true;
                }

                if (distance < orbitRadiusRange.max) {
                    // Start or continue orbiting
                    if (!particle.isOrbiting) {
                        particle.isOrbiting = true;
                        particle.orbitRadius = orbitRadiusRange.min + Math.random() * (orbitRadiusRange.max - orbitRadiusRange.min);
                        particle.angle = Math.atan2(dy, dx); // Initialize angle relative to mouse for smooth entry
                    }

                    // Calculate target orbit position
                    particle.angle += orbitSpeed; 
                    const targetX = mouseX + Math.cos(particle.angle) * particle.orbitRadius;
                    const targetY = mouseY + Math.sin(particle.angle) * particle.orbitRadius;

                    // Attract towards the orbit target
                    const forceToOrbitX = (targetX - particle.x) * attractionStrength * 5; 
                    const forceToOrbitY = (targetY - particle.y) * attractionStrength * 5;

                    particle.vx += forceToOrbitX;
                    particle.vy += forceToOrbitY;

                } else {
                    // Only attraction, not yet in orbit range
                    if (particle.isOrbiting) { 
                        particle.isOrbiting = false;
                        particle.orbitRadius = 0;
                    }
                    
                    // Apply attraction force, proportional to distance
                    const forceFactor = (attractionRadius - distance) / attractionRadius; 
                    particle.vx += dx * attractionStrength * forceFactor;
                    particle.vy += dy * attractionStrength * forceFactor;
                }

                // Apply dampening to velocities
                particle.vx *= dampening;
                particle.vy *= dampening;

            } else {
                // Particle is outside attraction radius, return to floating state
                if (particle.isAttracted) { 
                    particle.isAttracted = false;
                    particle.isOrbiting = false;
                    particle.orbitRadius = 0;
                }

                // Apply dampening even when floating, so it's not infinite
                particle.vx *= dampening; 
                particle.vy *= dampening; 

                // Gently guide velocity towards the desired float speed
                const floatAdjustSpeed = 0.05; 
                particle.vx += (particle.floatSpeedX - particle.vx) * floatAdjustSpeed;
                particle.vy += (particle.floatSpeedY - particle.vy) * floatAdjustSpeed;

                // Apply rotation only when not attracted
                particle.rotation += particle.rotationSpeed;

                // Reset particle if it goes off screen (top)
                if (particle.y < -50) { 
                    particle.y = window.innerHeight + 50;
                    particle.x = Math.random() * window.innerWidth;
                    // Reset attraction velocities but not float speeds on respawn
                    particle.vx = 0; 
                    particle.vy = 0; 
                    particle.floatSpeedY = (0.5 + Math.random() * 1.5) * -1;
                    particle.floatSpeedX = (Math.random() - 0.5) * 0.5;
                    particle.rotation = Math.random() * 360;
                    particle.rotationSpeed = (Math.random() - 0.5) * 0.2;
                }
            }

            // Update particle's position in the DOM
            particle.x += particle.vx;
            particle.y += particle.vy;

            particle.style.left = particle.x + 'px';
            particle.style.top = particle.y + 'px';
            particle.style.transform = `rotate(${particle.rotation}deg)`; 

        });
        requestAnimationFrame(animateParticles); 
    }

    // --- Lógica para a animação do brilho da logo (mantida) ---
    function createLogoSparkPath(particlesContainer, onSparkFinishCallback) {
        if (!particlesContainer) return;

        particlesContainer.innerHTML = ''; 
        const numVertices = 6; 
        const radius = 42; 
        const rotationInputDegrees = 30; 
        const rotationOffsetRadians = (rotationInputDegrees * Math.PI) / 180;

        const logoCenterOffset = { x: -1, y: -6 };

        const spark = document.createElement('div');
        spark.className = 'logo-spark';
        particlesContainer.appendChild(spark);

        let keyframes = [];
        let totalDuration = 0;
        const segmentDuration = 0.3; 
        const pauseBetweenSegments = 0.05; 

        keyframes.push({
            transform: `translate(${logoCenterOffset.x}px, ${logoCenterOffset.y}px) rotate(${rotationOffsetRadians * (180 / Math.PI) + 88}deg)`,
            opacity: 0
        });

        for (let i = 0; i <= numVertices; i++) {
            let angle = (Math.PI * 2 / numVertices) * i + rotationOffsetRadians;
            const targetX = Math.cos(angle) * radius;
            const targetY = Math.sin(angle) * radius;
            const finalRotation = angle * (180 / Math.PI) + 88;

            keyframes.push({
                transform: `translate(${targetX + logoCenterOffset.x}px, ${targetY + logoCenterOffset.y}px) rotate(${finalRotation}deg)`,
                opacity: 1
            });
            totalDuration += segmentDuration;

            if (i < numVertices) {
                keyframes.push({
                    transform: `translate(${targetX + logoCenterOffset.x}px, ${targetY + logoCenterOffset.y}px) rotate(${finalRotation}deg)`,
                    opacity: 1
                });
                totalDuration += pauseBetweenSegments;
            }
        }

        keyframes[keyframes.length -1].opacity = 0;

        const timingOptions = {
            duration: totalDuration * 1000, 
            easing: 'ease-in-out',
            fill: 'forwards' 
        };

        const animation = spark.animate(keyframes, timingOptions);

        animation.onfinish = () => {
            spark.remove();
            if (onSparkFinishCallback) {
                onSparkFinishCallback();
            }
        };

        return animation; 
    }

    function setupLogoEffect() {
        const logo = document.querySelector('.logo');
        const logoParticlesContainer = document.getElementById('logoParticles');
        const logoRotationDuration = 2.6; 
        let isSparkAnimating = false; 
        let mouseIsOverLogo = false; 

        if (!logo || !logoParticlesContainer) return;

        logo.addEventListener('mouseenter', () => {
            mouseIsOverLogo = true;

            if (isSparkAnimating) {
                return;
            }

            logo.style.transform = 'rotate(180deg) scale(1.5)';

            setTimeout(() => {
                if (mouseIsOverLogo && !isSparkAnimating) {
                    isSparkAnimating = true;
                    createLogoSparkPath(logoParticlesContainer, () => {
                        isSparkAnimating = false; 
                        if (!mouseIsOverLogo) {
                            logo.style.transform = ''; 
                        }
                    });
                }
            }, logoRotationDuration * 1000);
        });

        logo.addEventListener('mouseleave', () => {
            mouseIsOverLogo = false;

            if (isSparkAnimating) {
                return;
            }

            logo.style.transform = ''; 
        });
    }

    // --- Efeito de seleção de livro na galeria (AGORA COM ASMR E EMPURRÃO VERTICAL E HORIZONTAL) ---
    function setupBookSelectionEffect() {
        const galleryItems = Array.from(document.querySelectorAll('.galeria a'));
        if (galleryItems.length === 0) return;

        const asmrAudios = [
            new Audio('audios/page-turn-1.mp3'),
            new Audio('audios/page-turn-2.mp3'),
            new Audio('audios/page-turn-3.mp3'),
            new Audio('audios/page-turn-4.mp3')
        ];
        asmrAudios.forEach(audio => audio.load());

        // Melhorando o cálculo de itens por linha
        // Vamos agrupar os itens por linha com base em suas posições y
        let rows = [];
        let currentRowY = -1; // Usar -1 para garantir que a primeira linha seja detectada

        galleryItems.forEach(item => {
            const itemRect = item.getBoundingClientRect();
            // Se a posição Y do topo do item for significativamente diferente da linha atual, comece uma nova linha
            if (Math.abs(itemRect.top - currentRowY) > 5) { // 5px de tolerância
                currentRowY = itemRect.top;
                rows.push([]); // Adiciona uma nova linha
            }
            rows[rows.length - 1].push(item); // Adiciona o item à última linha
        });

        // Agora, para cada item, podemos encontrar seu índice global e também sua linha e coluna
        galleryItems.forEach((item, index) => {
            item.addEventListener('mouseenter', function() {
                this.classList.add('selected-book');
                
                // Empurrão Horizontal (mantido como está, pois funciona bem)
                const prevSibling = this.previousElementSibling;
                if (prevSibling && prevSibling.matches && prevSibling.matches('.galeria a')) {
                    prevSibling.classList.add('pushed-aside-right');
                }
                const nextSibling = this.nextElementSibling;
                if (nextSibling && nextSibling.matches && nextSibling.matches('.galeria a')) {
                    nextSibling.classList.add('pushed-aside-left');
                }

                // Empurrão Vertical (LÓGICA REVISADA)
                // Encontrar a linha e coluna do item atual
                let currentRowIndex = -1;
                let currentColIndex = -1;
                for (let r = 0; r < rows.length; r++) {
                    const foundColIndex = rows[r].indexOf(item);
                    if (foundColIndex !== -1) {
                        currentRowIndex = r;
                        currentColIndex = foundColIndex;
                        break;
                    }
                }

                if (currentRowIndex !== -1) {
                    // Item na linha de cima (mesma coluna)
                    if (currentRowIndex > 0) {
                        const itemAbove = rows[currentRowIndex - 1][currentColIndex];
                        if (itemAbove) {
                            itemAbove.classList.add('pushed-down'); // Empurra o item de CIMA para BAIXO
                        }
                    }

                    // Item na linha de baixo (mesma coluna)
                    if (currentRowIndex < rows.length - 1) {
                        const itemBelow = rows[currentRowIndex + 1][currentColIndex];
                        if (itemBelow) {
                            itemBelow.classList.add('pushed-up'); // Empurra o item de BAIXO para CIMA
                        }
                    }
                }

                // Efeito ASMR (mantido)
                const randomIndex = Math.floor(Math.random() * asmrAudios.length);
                const audio = asmrAudios[randomIndex].cloneNode();
                audio.volume = 0.4;
                audio.play().catch(e => console.error("Erro ao tocar áudio ASMR:", e));
            });

            item.addEventListener('mouseleave', function() {
                this.classList.remove('selected-book');
                
                // Remove empurrão Horizontal (mantido)
                const prevSibling = this.previousElementSibling;
                if (prevSibling && prevSibling.matches && prevSibling.matches('.galeria a')) {
                    prevSibling.classList.remove('pushed-aside-right');
                }
                const nextSibling = this.nextElementSibling;
                if (nextSibling && nextSibling.matches && nextSibling.matches('.galeria a')) {
                    nextSibling.classList.remove('pushed-aside-left');
                }

                // Remove empurrão Vertical (LÓGICA REVISADA)
                let currentRowIndex = -1;
                let currentColIndex = -1;
                for (let r = 0; r < rows.length; r++) {
                    const foundColIndex = rows[r].indexOf(item);
                    if (foundColIndex !== -1) {
                        currentRowIndex = r;
                        currentColIndex = foundColIndex;
                        break;
                    }
                }

                if (currentRowIndex !== -1) {
                    // Item na linha de cima
                    if (currentRowIndex > 0) {
                        const itemAbove = rows[currentRowIndex - 1][currentColIndex];
                        if (itemAbove) {
                            itemAbove.classList.remove('pushed-down');
                        }
                    }

                    // Item na linha de baixo
                    if (currentRowIndex < rows.length - 1) {
                        const itemBelow = rows[currentRowIndex + 1][currentColIndex];
                        if (itemBelow) {
                            itemBelow.classList.remove('pushed-up');
                        }
                    }
                }
            });
        });
    }

    // --- Cursor personalizado (mantido) ---
    function setupCustomCursor() {
      const cursor = document.getElementById('cursor');
      if (!cursor) return;
      let cursorX = 0, cursorY = 0; 
      const cursorSizeOffset = cursor.offsetWidth / 2; 

      document.addEventListener('mousemove', (e) => { 
        mouseX = e.clientX; 
        mouseY = e.clientY; 
      });

      function animateCursor() {
        cursorX += (mouseX - cursorX) * 0.12; 
        cursorY += (mouseY - cursorY) * 0.12; 
        cursor.style.left = cursorX - cursorSizeOffset + 'px';
        cursor.style.top = cursorY - cursorSizeOffset + 'px';
        requestAnimationFrame(animateCursor); 
      }
      animateCursor(); 

      const interactiveElements = document.querySelectorAll('a, img.logo');
      interactiveElements.forEach(el => {
        el.addEventListener('mouseenter', () => { cursor.style.transform = 'scale(1.3)'; });
        el.addEventListener('mouseleave', () => { cursor.style.transform = 'scale(1)'; });
      });
    }

    // --- Inicialização de todos os efeitos quando o DOM estiver carregado ---
    document.addEventListener('DOMContentLoaded', () => {
      const particlesContainer = document.getElementById('particles');
      const miniParticlesContainer = document.getElementById('miniParticles');
      const extraParticlesContainer = document.getElementById('extraParticles');

      createParticles(particlesContainer, 'particle', 25, 15, 10, 0, 15);
      createParticles(miniParticlesContainer, 'mini-particle', 80, 20, 15, 0, 20);
      createParticles(extraParticlesContainer, 'extra-particle', 60, 25, 20, 0, 25);

      animateParticles(); 

      setupCustomCursor();
      setupLogoEffect();
      setupBookSelectionEffect(); // Chamar aqui após o DOM estar pronto
    });
  </script>
</body>
</html>
