<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Biblioteca Oculta</title>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@600&family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="particles" id="particles"></div>
  <div class="mini-particles" id="miniParticles"></div>
  <div class="extra-particles" id="extraParticles"></div>

  <div class="asmr-gradients"></div>
  <div class="light-waves"></div>
  
  <div class="custom-cursor" id="cursor"></div>

  <header>
    <div class="logo-container" style="position: relative; display: inline-block;">
      <img src="logo.png" alt="Logo" class="logo" />
      <div class="logo-particles" id="logoParticles"></div>
    </div>
  </header>

  <section class="galeria">
    <a href="livros/livro1.pdf" target="_blank" data-asmr-src="audios/page-turn-1.mp3"><img src="capas/livro1.png" alt="Livro 1"></a>
    <a href="livros/livro2.pdf" target="_blank" data-asmr-src="audios/page-turn-2.mp3"><img src="capas/livro2.png" alt="Livro 2"></a>
    <a href="livros/livro3.pdf" target="_blank" data-asmr-src="audios/page-turn-3.mp3"><img src="capas/livro3.png" alt="Livro 3"></a>
    <a href="livros/livro4.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro4.png" alt="Livro 4"></a>
    <a href="livros/livro5.pdf" target="_blank" data-asmr-src="audios/page-turn-1.mp3"><img src="capas/livro5.jpg" alt="Livro 5"></a>
    <a href="livros/livro6.pdf" target="_blank" data-asmr-src="audios/page-turn-2.mp3"><img src="capas/livro6.png" alt="Livro 6"></a>
    <a href="livros/livro7.pdf" target="_blank" data-asmr-src="audios/page-turn-3.mp3"><img src="capas/livro7.jpg" alt="Livro 7"></a>
    <a href="livros/livro8.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro8.png" alt="Livro 8"></a>
    <a href="livros/livro9.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro9.png" alt="Livro 9"></a>
    <a href="livros/livro10.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro10.png" alt="Livro 10"></a>
    <a href="livros/livro11.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro11.png" alt="Livro 11"></a>
    <a href="livros/livro12.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro12.png" alt="Livro 12"></a>
    <a href="livros/livro13.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro13.png" alt="Livro 13"></a>
    <a href="livros/livro14.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro14.png" alt="Livro 14"></a>
    <a href="livros/livro15.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro15.png" alt="Livro 15"></a>
    <a href="livros/livro16.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro16.png" alt="Livro 16"></a>
    <a href="livros/livro17.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro17.png" alt="Livro 17"></a>
    <a href="livros/livro18.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro18.png" alt="Livro 18"></a>
    <a href="livros/livro19.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro19.png" alt="Livro 19"></a>
    <a href="livros/livro20.pdf" target="_blank" data-asmr-src="audios/page-turn-4.mp3"><img src="capas/livro20.png" alt="Livro 20"></a>
  </section>

  <footer>
    Biblioteca Oculta
  </footer>

  <script>
    // --- Funções para criar partículas de fundo ---
    function createParticles(container, className, count, minDuration, maxDuration, minDelay, maxDelay) {
      if (!container) return;
      container.innerHTML = ''; // Limpa o contêiner

      for (let i = 0; i < count; i++) {
        const particle = document.createElement('div');
        particle.className = className;
        
        particle.x = Math.random() * window.innerWidth;
        particle.y = window.innerHeight + Math.random() * 100;

        particle.vx = 0;
        particle.vy = 0;

        particle.floatSpeedY = (0.5 + Math.random() * 1.5) * -1;
        particle.floatSpeedX = (Math.random() - 0.5) * 0.5;
        particle.rotation = Math.random() * 360;
        particle.rotationSpeed = (Math.random() - 0.5) * 0.2;

        particle.angle = Math.random() * Math.PI * 2;
        particle.orbitRadius = 0;
        particle.isOrbiting = false;
        particle.isAttracted = false;

        particle.style.left = particle.x + 'px';
        particle.style.top = particle.y + 'px';
        
        const delay = (minDelay + Math.random() * (maxDelay - minDelay)) * 1000;
        setTimeout(() => {
          container.appendChild(particle);
          allParticles.push(particle);
        }, delay);
      }
    }

    // --- Variáveis e Função para o efeito de atração e órbita das partículas (buraco negro) ---
    let mouseX = 0;
    let mouseY = 0;
    const attractionRadius = 150;
    const orbitRadiusRange = { min: 30, max: 90 };
    const attractionStrength = 0.001;
    const orbitSpeed = 0.03;
    const dampening = 0.95;

    let allParticles = []; 

    function animateParticles() {
        allParticles.forEach(particle => {
            const dx = mouseX - particle.x;
            const dy = mouseY - particle.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < attractionRadius) {
                if (!particle.isAttracted) {
                    particle.isAttracted = true;
                }

                if (distance < orbitRadiusRange.max) {
                    if (!particle.isOrbiting) {
                        particle.isOrbiting = true;
                        particle.orbitRadius = orbitRadiusRange.min + Math.random() * (orbitRadiusRange.max - orbitRadiusRange.min);
                        particle.angle = Math.atan2(dy, dx);
                    }

                    particle.angle += orbitSpeed; 
                    const targetX = mouseX + Math.cos(particle.angle) * particle.orbitRadius;
                    const targetY = mouseY + Math.sin(particle.angle) * particle.orbitRadius;

                    const forceToOrbitX = (targetX - particle.x) * attractionStrength * 5; 
                    const forceToOrbitY = (targetY - particle.y) * attractionStrength * 5;

                    particle.vx += forceToOrbitX;
                    particle.vy += forceToOrbitY;

                } else {
                    if (particle.isOrbiting) { 
                        particle.isOrbiting = false;
                        particle.orbitRadius = 0;
                    }
                    
                    const forceFactor = (attractionRadius - distance) / attractionRadius; 
                    particle.vx += dx * attractionStrength * forceFactor;
                    particle.vy += dy * attractionStrength * forceFactor;
                }

                particle.vx *= dampening;
                particle.vy *= dampening;

            } else {
                if (particle.isAttracted) { 
                    particle.isAttracted = false;
                    particle.isOrbiting = false;
                    particle.orbitRadius = 0;
                }

                particle.vx *= dampening; 
                particle.vy *= dampening; 

                const floatAdjustSpeed = 0.05; 
                particle.vx += (particle.floatSpeedX - particle.vx) * floatAdjustSpeed;
                particle.vy += (particle.floatSpeedY - particle.vy) * floatAdjustSpeed;

                particle.rotation += particle.rotationSpeed;

                if (particle.y < -50) { 
                    particle.y = window.innerHeight + 50;
                    particle.x = Math.random() * window.innerWidth;
                    particle.vx = 0; 
                    particle.vy = 0; 
                    particle.floatSpeedY = (0.5 + Math.random() * 1.5) * -1;
                    particle.floatSpeedX = (Math.random() - 0.5) * 0.5;
                    particle.rotation = Math.random() * 360;
                    particle.rotationSpeed = (Math.random() - 0.5) * 0.2;
                }
            }

            particle.x += particle.vx;
            particle.y += particle.vy;

            particle.style.left = particle.x + 'px';
            particle.style.top = particle.y + 'px';
            particle.style.transform = `rotate(${particle.rotation}deg)`; 

        });
        requestAnimationFrame(animateParticles); 
    }

    // --- Lógica para a animação do brilho da logo ---
    function createLogoSparkPath(particlesContainer, onSparkFinishCallback) {
        if (!particlesContainer) return;

        particlesContainer.innerHTML = ''; 
        const numVertices = 6; 
        const radius = 42; 
        const rotationInputDegrees = 30; 
        const rotationOffsetRadians = (rotationInputDegrees * Math.PI) / 180;

        const logoCenterOffset = { x: -1, y: -6 };

        const spark = document.createElement('div');
        spark.className = 'logo-spark';
        particlesContainer.appendChild(spark);

        let keyframes = [];
        let totalDuration = 0;
        const segmentDuration = 0.3; 
        const pauseBetweenSegments = 0.05; 

        keyframes.push({
            transform: `translate(${logoCenterOffset.x}px, ${logoCenterOffset.y}px) rotate(${rotationOffsetRadians * (180 / Math.PI) + 88}deg)`,
            opacity: 0
        });

        for (let i = 0; i <= numVertices; i++) {
            let angle = (Math.PI * 2 / numVertices) * i + rotationOffsetRadians;
            const targetX = Math.cos(angle) * radius;
            const targetY = Math.sin(angle) * radius;
            const finalRotation = angle * (180 / Math.PI) + 88;

            keyframes.push({
                transform: `translate(${targetX + logoCenterOffset.x}px, ${targetY + logoCenterOffset.y}px) rotate(${finalRotation}deg)`,
                opacity: 1
            });
            totalDuration += segmentDuration;

            if (i < numVertices) {
                keyframes.push({
                    transform: `translate(${targetX + logoCenterOffset.x}px, ${targetY + logoCenterOffset.y}px) rotate(${finalRotation}deg)`,
                    opacity: 1
                });
                totalDuration += pauseBetweenSegments;
            }
        }

        keyframes[keyframes.length -1].opacity = 0;

        const timingOptions = {
            duration: totalDuration * 1000, 
            easing: 'ease-in-out',
            fill: 'forwards' 
        };

        const animation = spark.animate(keyframes, timingOptions);

        animation.onfinish = () => {
            spark.remove();
            if (onSparkFinishCallback) {
                onSparkFinishCallback();
            }
        };

        return animation; 
    }

    function setupLogoEffect() {
        const logo = document.querySelector('.logo');
        const logoParticlesContainer = document.getElementById('logoParticles');
        const logoRotationDuration = 2.6; 
        let isSparkAnimating = false; 
        let mouseIsOverLogo = false; 
        let sparkTimer; // Variável para armazenar o ID do timer

        if (!logo || !logoParticlesContainer) return;

        logo.addEventListener('mouseenter', () => {
            mouseIsOverLogo = true;

            if (isSparkAnimating) {
                return;
            }

            logo.style.transform = 'rotate(180deg) scale(1.5)';

            // Limpa qualquer timer anterior para evitar múltiplos timers
            if (sparkTimer) {
                clearTimeout(sparkTimer);
            }

            // Inicia o timer para os sparks APÓS a rotação + o atraso desejado (1 segundo)
            sparkTimer = setTimeout(() => {
                if (mouseIsOverLogo && !isSparkAnimating) {
                    isSparkAnimating = true;
                    createLogoSparkPath(logoParticlesContainer, () => {
                        isSparkAnimating = false; 
                        if (!mouseIsOverLogo) {
                            logo.style.transform = ''; 
                        }
                    });
                }
            }, (logoRotationDuration * 1000) + 700); // Adiciona 700ms ao tempo de rotação
        });

        logo.addEventListener('mouseleave', () => {
            mouseIsOverLogo = false;

            // Limpa o timer dos sparks quando o mouse sai, se ele ainda estiver ativo
            if (sparkTimer) {
                clearTimeout(sparkTimer);
            }

            if (isSparkAnimating) {
                return;
            }

            logo.style.transform = ''; 
        });
    }

    // --- Efeito de seleção de livro na galeria (AGORA COM ASMR E EMPURRÃO VERTICAL E HORIZONTAL) ---
    // Variável global para armazenar as linhas
    let cachedRows = [];

    function updateGalleryRows() {
        const galleryItems = Array.from(document.querySelectorAll('.galeria a'));
        if (galleryItems.length === 0) {
            cachedRows = [];
            return;
        }

        let tempRows = [];
        let currentY = -1; 
        const tolerance = 15; // Pode ajustar isso se 15 ainda for pouco/muito

        galleryItems.forEach(item => {
            const itemY = Math.floor(item.offsetTop); 

            if (tempRows.length === 0 || Math.abs(itemY - currentY) > tolerance) {
                currentY = itemY;
                tempRows.push([]); 
            }
            tempRows[tempRows.length - 1].push(item); 
        });
        cachedRows = tempRows;

        console.log("--- Rows Updated ---");
        cachedRows.forEach((row, rowIndex) => {
            console.log(`Row ${rowIndex}:`, row.map(item => item.querySelector('img').alt));
        });
        console.log("--------------------");
    }

    function setupBookSelectionEffect() {
        const galleryItems = Array.from(document.querySelectorAll('.galeria a'));
        if (galleryItems.length === 0) return;

        const asmrAudios = [
            new Audio('audios/page-turn-1.mp3'),
            new Audio('audios/page-turn-2.mp3'),
            new Audio('audios/page-turn-3.mp3'),
            new Audio('audios/page-turn-4.mp3')
        ];
        asmrAudios.forEach(audio => audio.load());

        updateGalleryRows(); 
        window.addEventListener('resize', updateGalleryRows);

        galleryItems.forEach((item, index) => {
            item.addEventListener('mouseenter', function() {
                this.classList.add('selected-book');
                
                const prevSibling = this.previousElementSibling;
                if (prevSibling && prevSibling.matches && prevSibling.matches('.galeria a')) {
                    prevSibling.classList.add('pushed-aside-right');
                }
                const nextSibling = this.nextElementSibling;
                if (nextSibling && nextSibling.matches && nextSibling.matches('.galeria a')) {
                    nextSibling.classList.add('pushed-aside-left');
                }

                let currentRowIndex = -1;
                let currentColIndex = -1;

                for (let r = 0; r < cachedRows.length; r++) {
                    const foundColIndex = cachedRows[r].indexOf(this);
                    if (foundColIndex !== -1) {
                        currentRowIndex = r;
                        currentColIndex = foundColIndex;
                        break;
                    }
                }
                
                console.log(`--- Hovered: ${this.querySelector('img').alt} (Row: ${currentRowIndex}, Col: ${currentColIndex}) ---`);


                if (currentRowIndex !== -1) {
                    if (currentRowIndex > 0) {
                        const itemAbove = cachedRows[currentRowIndex - 1][currentColIndex];
                        if (itemAbove) {
                            itemAbove.classList.add('pushed-down');
                            console.log(`  - Pushing DOWN: ${itemAbove.querySelector('img').alt}`);
                        } else {
                            console.warn(`  - WARNING: No item directly above in column ${currentColIndex} of row ${currentRowIndex - 1}. Row content:`, cachedRows[currentRowIndex - 1].map(i => i.querySelector('img').alt));
                        }
                    } else {
                        console.log(`  - No row above for ${this.querySelector('img').alt}`);
                    }

                    if (currentRowIndex < cachedRows.length - 1) {
                        const itemBelow = cachedRows[currentRowIndex + 1][currentColIndex];
                        if (itemBelow) {
                            itemBelow.classList.add('pushed-up');
                            console.log(`  - Pushing UP: ${itemBelow.querySelector('img').alt}`);
                        } else {
                            console.warn(`  - WARNING: No item directly below in column ${currentColIndex} of row ${currentRowIndex + 1}. Row content:`, cachedRows[currentRowIndex + 1].map(i => i.querySelector('img').alt));
                        }
                    }
                } else {
                    console.error(`  - ERROR: Item not found in cachedRows: ${this.querySelector('img').alt}. This should not happen.`);
                }

                const randomIndex = Math.floor(Math.random() * asmrAudios.length);
                const audio = asmrAudios[randomIndex].cloneNode();
                audio.volume = 0.4;
                audio.play().catch(e => console.error("Erro ao tocar áudio ASMR:", e));
            });

            item.addEventListener('mouseleave', function() {
                this.classList.remove('selected-book');
                
                const prevSibling = this.previousElementSibling;
                if (prevSibling && prevSibling.matches && prevSibling.matches('.galeria a')) {
                    prevSibling.classList.remove('pushed-aside-right');
                }
                const nextSibling = this.nextElementSibling;
                if (nextSibling && nextSibling.matches && nextSibling.matches('.galeria a')) {
                    nextSibling.classList.remove('pushed-aside-left');
                }

                let currentRowIndex = -1;
                let currentColIndex = -1;
                for (let r = 0; r < cachedRows.length; r++) {
                    const foundColIndex = cachedRows[r].indexOf(this);
                    if (foundColIndex !== -1) {
                        currentRowIndex = r;
                        currentColIndex = foundColIndex;
                        break;
                    }
                }

                if (currentRowIndex !== -1) {
                    if (currentRowIndex > 0) {
                        const itemAbove = cachedRows[currentRowIndex - 1][currentColIndex];
                        if (itemAbove) {
                            itemAbove.classList.remove('pushed-down');
                        }
                    }

                    if (currentRowIndex < cachedRows.length - 1) {
                        const itemBelow = cachedRows[currentRowIndex + 1][currentColIndex];
                        if (itemBelow) {
                            itemBelow.classList.remove('pushed-up');
                        }
                    }
                }
            });
        });
    }

    // --- Cursor personalizado ---
    function setupCustomCursor() {
      const cursor = document.getElementById('cursor');
      if (!cursor) return;
      let cursorX = 0, cursorY = 0; 
      const cursorSizeOffset = cursor.offsetWidth / 2; 

      document.addEventListener('mousemove', (e) => { 
        mouseX = e.clientX; 
        mouseY = e.clientY; 
      });

      function animateCursor() {
        cursorX += (mouseX - cursorX) * 0.12; 
        cursorY += (mouseY - cursorY) * 0.12; 
        cursor.style.left = cursorX - cursorSizeOffset + 'px';
        cursor.style.top = cursorY - cursorSizeOffset + 'px';
        requestAnimationFrame(animateCursor); 
      }
      animateCursor(); 

      const interactiveElements = document.querySelectorAll('a, img.logo');
      interactiveElements.forEach(el => {
        el.addEventListener('mouseenter', () => { cursor.style.transform = 'scale(1.3)'; });
        el.addEventListener('mouseleave', () => { cursor.style.transform = 'scale(1)'; });
      });
    }

    // --- Função para embaralhar um array (Fisher-Yates) ---
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]]; // Troca elementos
        }
    }

    // --- Inicialização de todos os efeitos quando o DOM estiver carregado ---
    document.addEventListener('DOMContentLoaded', () => {
      // 1. Embaralhar os livros primeiro
      const gallery = document.querySelector('.galeria');
      const galleryItems = Array.from(gallery.children); // Pega todos os filhos (os <a>)
      
      shuffleArray(galleryItems); // Embaralha o array de elementos

      // Remove os elementos existentes e os adiciona de volta na nova ordem
      galleryItems.forEach(item => gallery.appendChild(item));

      // 2. O restante da sua inicialização de efeitos
      const particlesContainer = document.getElementById('particles');
      const miniParticlesContainer = document.getElementById('miniParticles');
      const extraParticlesContainer = document.getElementById('extraParticles');

      createParticles(particlesContainer, 'particle', 19, 15, 10, 0, 15);
      createParticles(miniParticlesContainer, 'mini-particle', 60, 20, 15, 0, 20);
      createParticles(extraParticlesContainer, 'extra-particle', 45, 25, 20, 0, 25);

      animateParticles(); 

      setupCustomCursor();
      setupLogoEffect();
      // setupBookSelectionEffect DEVE ser chamado DEPOIS de randomizar,
      // pois ele depende da ordem final dos elementos.
      setupBookSelectionEffect(); 
    });
  </script>
</body>
</html>
